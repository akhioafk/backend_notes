#### Регулярные выражения (регулярки/regex)

Примеры регулярных выражений:
```
\d{3}-\d{2}-\d{4}
```
Соответсвует формату социального номера (например, 123-45-6789)
```
^[A-Za-z]+$
```
Соответсвует строке, состоящей только из букв (идущей от начала до конца строки).

1. **Базовые символы**
	* `" . "` - соответствует любому одному символу, кроме новой строки.
	* `" \d "` - соответствует любой цифре (эквивалентно `[0-9]`)
	* `" \D "` - соответствует любому нецифровому символу.
	* `" \w "` - соответствует любому символу, не являющемуся буквой или цифрой.

2. Классы символов
	* `[abc]` - соответствует любому символу из набора (a, b или c)
	* `[^abc]` - соответствует любому символу, не входящему в указанный набор.

3. Квантификаторы
	* `" * "` - соответствует нулю или более повторениям предыдущего символа или группы.
	* `" + "` - соответствует одному или более повторениям предыдущего символа или группы.
	* `" ? "` - соответствует нулю или одоному повторению предыдущего символа или группы.
	* `{n}` - соответствует ровно n повторениям предыдущего символа или группы.
	* `{n,}` - соответствует n и более повторениям.
	* `{n,m}` - соответсвует от n до m повторений.

4. Группировка и захват
	* `()` - используется для группировки символов и создания захватывающих групп, которые можно использовать для извлечения данных.
	* `(?:)` - используется для группировки без захвата.

5. Специальные символы
	* `" ^ "` - соответствует началу строки.
	* `" $ "` - соответствует концу строки.
	* `" | "` - оператор "или", который позволяет выбрать между несколькими альтернативами.

6. Экранирование
	* `" \ "` - используется для экранирования специальных символов, чтобы они воспринимались как обычные символы. Например, `" \. "` соответствует точке


####  Криптография
* **Хеши и хеш-функции (`crc32`, `md5`, `sha1`, `sha256`).**
Это алгоритм, который преобразует входные данные (сообщение) в фиксированного размера строку, называемую хешем. Преобразование выполняется таким образом, чтобы любые два разных входных данных приводили к разным хешам.
*Основное характеристики:*
1. Одно и то же входное сообщение всегда даст один и тот же хеш.
2. Хеш-функция быстрая при вычислении хеша.
3. Невозможно восстановить исходные данные только по их хешу.
4. Сложно найти два различных входных сообщения, которые дают одинаковый хеш.

*Применение хэш-функции:*
1. Хэши используют для проверки, не были ли данные изменены.
2. Вместо хранения паролей в базе данных, системы обычно сохраняют их хеши.
3. Хеши используются в цифровых подписях для обеспечения подлинности сообщения, который шифруется с помощью частного ключа отправителя.
4. Хеш-таблицы.

* **Цифровые подписи.**
 Пример процесса цифровой подписи
1. Отправитель: Петр хочет отправить документ с цифровой подписью.
    - Петр создает хеш документа.
    - Петр шифрует этот хеш своим частным ключом, создавая цифровую подпись.
    - Петр отправляет документ и цифровую подпись получателю.
2. **Получатель:** Мария получает документ и подпись.
    - Мария расшифровывает цифровую подпись с помощью открытого ключа Петра, чтобы получить хеш.
    - Мария хеширует документ, который она получила.
    - Мария сравнивает полученный хеш с расшифрованным хешем. Если они совпадают, это подтверждает, что документ не был изменен и что подпись принадлежит Петру.

* **Соль для подписей.**
Соль - это какое-либо значение, которое добавляется к данным перед тем, как они будут хешированы. Это делает запись уникальной и затрудняет атаки на хеш-функции, даже если исходные данные одинаковы.

*Применение соли*:
1. При хешировании данных, соль добавляется к данным до вычисления хеша.
2. Хеш-функция создает хэш из соли и данных (например, пароль), Соль и хэши сохраняются вместе.
3. При проверке соль извлекается, добавляется к введенному паролю, и создается новый хеш. Этот хеш сравнивается с сохраненным, чтобы проверить правильность пароля.

* **Коллизии хешей.**
Коллизия хешей происходит, когда две разные входные данные одинаковый результат при применении к ним хеш-функции. Это неизбежно, посклько входных данных обычно намного больше, чем количество возможных значений хеша.

*Методы разрешения коллизий:*
1. Использование качественных хеш-функций. В некриптографических приложениях популярны функции MurmurHash и CityHash, в криптографии - SHA-256.
2. Использование соли.
3. Увеличени длины хеша, то есть количества бит в хеше уменьшает вероятность коллизии, так как больше возможных значений. Например, SHA-512 вместо SHA-256.

* **Симметричное и асимметричное шифрование.**
Два основных подхода к защите данных в криптографии, они различаются способом управления ключами и принципами работы.

**Симметричное шифрование** использует один и тот же ключ для шифрования и расшифровки данных.
*Преимущества:*
1. Симметричные алгоритмы шифрования обычно быстрее, чем асимметричные.
2. Алгоритмы проще в реализации и требуют меньше вычислительных ресурсов.
*Недостатки:*
1. Передача ключа очень опасна, так как злоумышленники могут получить доступ к ключу.
2. Для безопасного общения между несколькими пользователями нужны уникальные ключи для каждой пары отправитель-получатель.

**Ассиметричное шифрование** использует два различных ключа: один для шифрования, другой для расшифровки. Эти ключи связаны математически и образуют пару: открытый ключ и закрытый ключ.
*Как работает:*
1. Открытый ключ используется для шифрования данных и может быть свободно распространен. Другие пользователи используют ваш открытый ключи чтобы зашифровать сообщение.
2. Закрытый ключ хранится в секрете и используется для расшифровки данных. Получив зашифрованный вашим открытым ключом сообщение, можете расшифровать сообщение только своим закрытым ключом.
*Преимущества:*
1. Безопасная передача ключа, ведь совсем не надо передавать свой закрытый ключ, что исключает риск перехвата.
2. Ассиметричное шифрование позволяет создавать цифровые подписи, которые подтверждают подлинность и целостность сообщения.
*Недостатки:*
1. Алгоритмы намного медленнее симметричных из-за сложности математических операций.
2. Требует больше вычислительных ресурсов.

* **Принцип работы TLS.**
TODO: i'm too tired for this shit


#### Форматы хранения и передачи данных

##### Текстовые
* JSON (JavaScript Object Notation)
JSON - это легковесный формат обмена данными, широко используемый для хранения и передачи данных, особенно в веб-разработке. Основан на синтаксисе JavaScript.

*Особенности JSON:*
1. Просто и легко читается как людьми, так и машинами
2. Поддерживает основные типа данных: строки, числа, булевы значения, массивы и объекты.
3. Универсальный формат который поддерживается почти всеми ЯП.
4. Не требует закрывающих тегов (как XML), что делает его менее избыточным.

*Пример JSON:*
```
{
"name": "myAPP",
"version": 1.0,
"settings": {
		"theme": "dark",
		"autoSave": true
	}
}
```


* YAML (YAML Ain't Markup Language)
YAML - формат данных для обеспечения удобочитаемости и легкости записи. Часто используется в конфигурационных файлах, особенно в экосистемах DevOps (Ansible, Kubernetes)

*Особенности YAML:*
1. Оптимизирован для чтения человеком.
2. Поддерживает сложные структуры данных, такие как списки, словари и даже ссылки на другие объекты в том же документе.
3. Позволяет использование разных стилей для представления данных. Можно записывать массивы как через запятую, так и на разных строках.
4. Менее строг в отношении синтаксиса.

*Пример YAML:*
```
name: myApp
version: 1.0
settings:
	theme: dark
	autoSave: true
```

* XML (eXtensible Markup Language)
XML - формат разметки, предназначенный для хранени и передачи данных. Также был разработан для обмена данными в интернете и используется в веб-сервисах.

*Особенности XML:*
1. Имеется возможность создавать собственные теги, что позволяет точно описывать данные любой сложности.
2. Может использовать схемы (DTD или XSD) для опеределения структуры данных чтобы обеспечивать строгую валидацию.
3. Поддерживается множеством библиотек и инструментов для работы с данными.

*Пример XML:*
```
<application>
  <name>myApp</name>
  <version>1.0</version>
  <settings>
    <theme>dark</theme>
    <autoSave>true</autoSave>
  </settings>
</application>
```

##### Бинарные
Бинарные форматы данных - это специализированные форматы, которые используются для хранения и передачи данных в компактном виде. Они более эффективны по сравнению с текстовыми форматами, поскольку позволяют уменьшить объём передаваемых данных и ускорить обработку.

* MessagePack
MessagePack - это бинарный формат сериализации данных, котоырй предназначен для передачи и хранения данных. Сохраняет структуру данных JSON, но преобразует в компактный формат.

*Особенности MessagePark:*
1. Преобразует данные в бинарный формат, который занимает значительно меньше места по сравнению с JSON.
2. Более быстрая передача данных и их десериализацию, благодаря преобразованию в бинарный формат.
3. Поддерживает те же типы данных, что и JSON, что делает его интегрируемым в любое приложение где используется JSON.

* BSON (Binary JSON)
BSON - это бинарный формат, который представляет документо-ориентированный формат как JSON. Основной формат хранения данных в MongoDB.

*Особенности BSON:*
1. Помимо стандартных типов данных JSON, BSON поддерживает дополнительные типы как `Date`, `Binary`, `ObjectId`.
2. Оптимизирован для MongoDB.
3. Поддержка вложенных документов, хранение и обработка сложных вложенных структур данных.

* Protocol Buffers (ProtoBuf)
Protocol Buffers - это бинарный формат сериализации, разработанный Google. Широко используется между различными сервисами и приложениями.

*Особенности Protocol Buffers:*
1. Обеспечивает высокую степень сжатия данных, и минимальные накладные расходы на передачу. Идеально для использования в средах с ограниченными ресурсами.
2. Поддерживает изменение структуры данных, сохраняя совместимость с предыдущими версиями, что важно для долгосрочных проектов.

```
ProtoBuf часто используется в распределенных системах и микросервисах.
```



