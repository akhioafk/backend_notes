(источник: https://habr.com/ru/articles/822707/)
Docker - это платформа, позволяющая запускать приложения в изолированных **контейнерах**. Контейнеры позволяют стабильно работать в любой среде, будь то компьютер разработчика/сервер/облако/кластер Kubernetes (k8s).

Разработчики могут заниматься приложением не волнуясь о проблемах совместимости и настройке окружения.

Есть две основные единицы для работы Docker-а: **образ** и **контейнер**.


## Контейнеры

Контейнеры - легковесные, изолированные среды выполнения, внутри которых работают выполнения.

##### Виртуальные машины:
* Виртуальные машины в отличии от контейнеров используют собственную ОС, ядро, драйверы. Это означает что на одном физическом сервере может быть несколько ОС с разными ядрами. 
* И поэтому использование ресурсов может быть более затратным.

##### Контейнеры:
* А контейнеры используют ядро хостовой ОС, а не запускает собственное, и из-за этого они менее ресурскоемкими.
* Также они изолируются на уровне ОС, используя технологии которые позволяют разделять ресурсы и предотвразать конфликты между контейнерами.
* Контейнеры запускаются быстрее так как не требуют полной загрузки ОС.
* Docker гарантирует, что контейнер, который работает на машине разработчика, будет также работать и на сервере, без каких-либо неожиданностей.


## Образы

Образ Docker - это статичное описание контейнера, включающее в себя все зависимости, настройки окружения, библиотеки, необходимые для приложения.

Образы часто создаются на базе других образов, благодаря системе слоев которая позволяет создавать и сохранять изменения поверх базового образа.

```
Например, можно взять официальный образ Go и добавить свой код, получив новый образ, готовый к развертыванию
```
![[Pasted image 20240828144000.png]]


## Запуск первого контейнера

Запуск контейнера - основное действие которое выполняется в Docker. 

Пример запуска **hello world**:
```
docker run hello-world
```

Docker ищет образ hello-world в локальном хранилище, если образ не находится, то Docker скачает его с Docker Hub. Далее он создает контейнер на основе этого образа и запускает его.

```
Hello from Docker!
This message shows that your installation appears to be working correctly.
```


## Основные команды

Официальный образ операционный системы Ubuntu:
```
docker run -it ubuntu bash
```

* -i (--interactive) означает, что контейнер будет получать стандартный поток ввода с хоста и направлять его в приложение, работающее в контейнере. По-умолчанию контейнеры стартуют изолированно, и stdin запущенного приложения не имеет связи с внешним миром.
* -t (--tty) указывает Docker-у создать для запущенного приложения псевдотерминал, чтобы позволит работать с ним из моего терминала.

Для того чтобы остановить контейнер:
```
docker stop <container_id>
``` 

Чтобы узнать идентификатор контейнера:
```
docker ps
```
Она выводит список запущенных контейнеров вместе с их идентификатором.

Чтобы перезапустить контейнер:
```
docker restart <container_id>
```

Чтобы удалить контейнер, сначала надо **остановить** его, а затем использовать команду:
```
docker rm <container_id>
```

Для одновременной остановки и удаления контейнера можно использовать флаг -f (force):
```
docker rm -f <container_id>
```

## Управление образами Docker

Для загрузки образа без его запуска используется:
```
docker pull
(docker pull ubuntu)
(docker pull ubuntu:20.04)
```

Чтобы увидеть все доступные образы на своем компьютере 
(а также чтобы получить идентификатор образа):
```
docker images
```

Для удаления образа:
```
docker rmi (remove image) <image_id>
```


## Dockerfile и образы Docker

Образы Docker служат шаблоном для создания контейнеров, и описываются с помощью Dockerfile.

**Dockerfile** - это текстовый файл специального формата, который содержит команды для сборки Docker-образа.

**Контекст Dockerfile** - это набор файлов, которые будут отправлены на **Docker daemon** для сборки образа. В основном это директория, в которой находится сам Dockerfile и все файлы необходимые для сборки (тот же написанный код).

##### Простой пример Dockerfile

```
# Указываем базовый образ
FROM node:14
# Устанавливаем рабочую директорию внутри будущего контейнера
WORKDIR /app
# Копируем package.json и package-lock.json в /app 
# (./ из-за WORKDIR)
COPY package*.json ./
# Устанавливаем зависимости
RUN npm install
# Копируем файлы приложения (с хоста в образ)
COPY . .
# Открываем порт
EXPOSE 3000
# Запускаем приложение
CMD ["node", "server.js"]
```

Теперь чтобы собрать приложение:
```
docker build -t node-app:latest
```

* *-t* указывает Docker собрать образ с тегом
* *node-app*- название образа
* *latest* - тег

После того, как Docker заврешит сборку, можно запустить приложение:
```
docker run node-app
```

#### Важное замечание
Каждая команда создает свой собственный слой образа, из-за этого образы могут раздуваться до огромных размеров. Для того, чтобы этого не происходило, существует поэтапная сборка.

### Поэтапная (multistage) сборка

Поэтапная сборка позволяет уменшить размеры итоговых образов, используя команду FROM.image: mysql:latest        
		​￼volumes:            
			-'app-db:/var/lib/mysql'        
		​￼environment:            
			DB_PASSWORD: password        
		​￼networks:            
			- app-network

```
# BUILD STAGE
FROM golang:1.16 AS build
WORKDIR /go/src/app
COPY . .
RUN go build -o myapp

# RUN STAGE
FROM alpine:latest
WORKDIR /root/
COPY --from=build /go/src/app/myapp .
CMD ["./myapp"]
```

### Docker Hub, репозитории образов

Docker Hub - репозитории, который дает возможность обмениваться и управлять контейнерными образами.

С помощью Docker Hub:
* Искать и загружать публичные образы
* Создавать и делиться собственными образами
* Управлять автоматическими сборками и интграциями с системой контроля версий.

Основные процессы работы с Docker Hub - это загрузка (pull) и выгрузка (push) образов.

```
# To import
docker pull
(docker pull ubuntu:latest)

# To export
# Firstly tag your image
docker tag <image_id>your_dockerhub_username/repo_name:tag
# Then push
docker push your_dockerhub_username/repo_name:tag
```

Docker Hub прдоставляет множество готовых образов:
* Alpine Linux (alpine) - дистрибутив Linux, размером 5 МБ
* Node.js (node) - среда выполнения JavaScript, для запуска серверного кода
* Redis (redis) - in-memory база данных
и т.д

### Сети

Сети - одна из ключевых составляющих контейнеризации в Docker. Его отсутствие приведет к проблемам с доступом к вашим сервисам.

Docker предоставляет несколько драйверов сетевого взаймодействия, но основные - bridge, host и overlay.

Для списка доступных сетей:
```
docker network ls
```

Для отключения контейнера от сети:
```
docker network disconnect <network_name> <container_id>
```

Чтобы удалить сеть:
```
docker network rm <network_name>
```


#### Bridge
Используется по умолчанию, создается виртуальный мост (bridge), который позволяет контейнерам общаться друг с другом и с хост машиной.

При запуске контейнера создается виртуальный интерфейс и подключается к мосту, предоставляя контейнерам IP-адреса из определенного диапазона, также Bridge-сеть позволяет изолировать контейнеры от других сетевых интерфейсов хост-машины.

Для подключения контейнера к сети, надо указать *имя сети* при запуске контейнера с использованием флага --network

```
docker network create --driver bridge app_network

docker run -d --network app_network --name app nginx
```

#### Host
В этом режиме контейнер использует сетевой стек хост-машины, что означает что контейнер и хост имеют общий IP-адрес и порты. Полезна тем что уменьшает сетевую задержку, но уменьшает изоляцию между контейнером и хостом

```
docker run -d --network host nginx
```

#### Overlay
Этот режим используется в кластерных средах и Docker Swarm.

Данная сеть позволяет контейнерам, работающих на разных физических или виртуальных машинах, общаться друг с другом, будто они находятся на одной сети. Это достигаемся путем создания распределенной сети поверх существующей физической инфраструктуры. В частности Overlay используется в микросервисной архитектуре и в распределенных системах.

Для создания такой сети:
```
docker network create --driver overlay --subnet 10.0.9.0/24 my_overlay_network
```

После подключения к одной сети, контейнеры могут общаться друг с другом по имени хоста:
```
docker exec container2 ping container1
```
Это происходит благодаря встроенному DNS-сервису Docker.


### Docker Volumes и связывание контейнера с файловой системой хоста (bind mounts)

**Volumes** и **bind mounts** - ключевые механизмы для работы с данными в контейнерах, они необходимы чтобы эффективно управлять данными, обспечивать их сохранность и доступность.

**Docker Volumes** существуют, чтобы хранить данные отдельно от контейнера. И даже если контейнер удалится, данные хранящиеся в volume, останутся нетронутыми.

**Bind Mounts** отличается от Volumes, данный подход представляет собой простое монтирование директорий с хоста в директории внутри контейнера. Это позволяет контейнерам иметь прямой доступ к данных на хосте, что удобно для среды разработки и тестирования.

При использовании Bind Mounts изменения, внесенные в файлы на хосте, будут отражаться внутри контейнера, и наоборот.

```
volume: type=volume,src=my_volume,target=/usr/local/data
bind mount: type=bind,src=/path/to/data,target=/usr/local/data
```

|                               | **Volumes**     | **Bind mounts**           |
| ----------------------------- | --------------- | ------------------------- |
| Путь на хосте                 | Выбирает Docker | Указывается разработчиком |
| Создает новый volume          | Да              | Нет                       |
| Поддерживает драйверы volumes | Да              | Нет                       |

### Docker Compose

Docker Compose - это инструмент, который используется для упрощения работы с многоконтейнерными приложениями.

Основные возможности:
* Декларативное описание сервисов, volumes и networks в формате yaml
* Управление всеми службами, указанными в конфигурационном файле, при помощи единой утилиты docker compose
* Управление жизненным циклом контейнеров

Docker Compose позволяет автоматизировать процесс ручной настройки сетей, volumes и серии команд для каждого контейнера.
Для этого стоить создать файл docker-compose.yml в котором описана конфигурация приложения.

```
services:
	web:
		image: nginx:latest
		ports:
				- "8000:80"
		networks:
				- app-network    
	app:         
		build:            
			args:                
				user: www-data                
				uid: 33                
				app_mode: development            
			context: .            
			dockerfile: Dockerfile         
		restart: always         
		image: app         
		container_name: app         
		working_dir: /var/www/         
		volumes:             
			-'./:/var/www'         
		networks:             
			- app-network    
	db:        
		image: mysql:latest        
		volumes:            
			-'app-db:/var/lib/mysql'        
		environment:            
			DB_PASSWORD: password        
		networks:            
			- app-network
networks:    
	app-network:        
		name: app-network            
			driver: bridge
volumes:    
	app-db:        
		driver: local
```

Для запуска всех служю описанных в docker-compose.yml:
```
docker compose up
(docker-compose up)
```

Для запуска контейнеров в фоновом режиме, использовать флаг -d:
```
docker compose up -d
```


#### Управление контейнерами

Для управления службами Docker Compose предоставляет команды:
* Просмотр списка запущенных контейнеров: `docker compose ps`
* Просмотр всех контейнеров: `docker compose ps -a`
* Просмотр логов приложения: `docker compose logs <container_name>`
* Перезапуск контейнера: `docker compose restart <container_name>`