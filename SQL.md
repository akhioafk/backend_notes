(источник:https://habr.com/ru/companies/tensor/articles/779698/)
SQL - *декларативный* язык программирования, то есть мы лишь даем запрос и получаем ответ, никак не влияя на получаемый ответ в процессе.

PostgreSQL - является *реляционной* СУБД, то есть в такой базе будут находится связанные таблицы.
Преимущество *нереляционных* СУБД в том, что под конкретную задачу подобрать наиболее подходящую структуру: Key-Value, документарные, графовые, поисковые. Так как никак не конкретизирует структуру.

### Хранение данных в реляционных базах

![[Pasted image 20240830111303.jpg]]

Между собой таблицы связываются какими-то отношениями, которые определяются ключами. У любой таблицы есть **первичный ключ** (Primary Key, PK), чтобы идентифицировать любую из строк данной таблицы.

Но бывают случаи когда может и не быть первичного ключа, и вместо него используется *суррогатный ключ*, либо вообще не добавляется.

А вот чтобы "сослаться" со стороны подчиненной таблицы используются **внешние ключи** (Foreign Keys, FK). 

В целом, внешний ключ может ссылаться не только на первичный, но и на любой **уникальный ключ** (Unique Key). Которых может быть несколько в самой таблице.

![[Pasted image 20240830112050.jpg]]


### Особенности PostgreSQL

PostgreSQL использует **клиент-серверную архитектуру**. То есть всегда есть некоторый клиент, который формирует запрос по собственному протоколу "поверх" TCP/IP отправляет его серверу. И мы лишь получаем результат.
 
Чтобы использовать данную СУБД, придется использовать утилиту **psql** - нативный консольный клиент.

#### Базовые SQL-команды

![[Pasted image 20240830113318.png]]

Самые первые: **CREATE DATABASE**, чтобы создать базу, и **CREATE TABLE**, чтобы создать таблицу в ней.
```
CREATE DATABASE tst;

CREATE TABLE tbl(
	k            -- имя поля
		integer,  -- тип поля
    v
	   text,
);
```

Всегда нужно сразу определять имена и типы полей, формат записей.

##### INSERT
INSERT отвечает за добавление данных, за их вставку в таблицу.
```
INSERT INTO tbl(         -- куда будем вставлять данные
	k,                   -- имена полей
	v
)
VALUES                   -- перечисляем вставляемые строки
	(1, '1st string),
	(102, 'another string),
	(3, NULL);           -- вовсе не ''
```

Мы указываем, в какую таблицу и в какие поля должны быть добавлены данные, и, в простейшей форме `INSERT ... VALUES`, прямо перечисляем те строки, которые хотим вставить.

##### UPDATE
Чтобы поправить данные, используем команду UPDATE.
```
UPDATE
	tbl
SET
	k = k - 100,     --правила изменения значений полей
	v = '2nd string'
WHERE
	k = 102          -- условия отбора строк
```

##### DELETE
Для удаления поля, используется команда DELETE.
```
DELETE FROM
	tbl
WHERE
	v IS NULL;
```

С `NULL`-значениями нельзя пользоваться операторами типа "равно/неравно", для них свои операторы `IS`. В данном случае используем `IS NULL`, чтобы проверить на совпадение с `NULL`-значением.

##### ... RETURNING 
Чтобы удалить запись, и также узнать какие были удалены, используется команда `RETURNING`.
```
DELETE FROM
	tbl
WHERE
	v IS NULL
RETURNING *;
```

Используя `*` мы указываем "все поля". В данном случае мы увидим, что удаляется одна строка со значением 3 в поле `k`.
```
k       |  v
integer | text
3       |
```

##### SELECT
Чтобы взять записи и показать их, используем команду `SELECT`.
```
SELECT
	*
FROM
	tbl;
```

и получаем:
```
k       | v
integer | text
1       | 1st string
2       | 2nd string
```

#### Базовый синтаксис

```
-- это однострочный комментарий
/* а это -
		 - многострочный */

fld, Fld, FLD   -- это поле/столбец (приводятся к lower case)

"Fld"           -- это тоже поле оно с регистрозависимости
'str'           -- это строка

'st''r'         -- это строка с одинарным апострофом
```

Основные две заметки по синтаксису:
1. Поля регистронезависимы
2. Строковые литералы бывают как в апострофах, или в виде эскейп-последовательности

#### Базовые типы данных
Все типы PostgreSQL можно разделить на базовые (числовые, символьные, даты/времени и логический тип) и расширеннные.

##### Числовые типы
Числовой тип определяется своей разрядностью: 2-, 4- и 8-байтные целочисленные? 4- и 8- байтовые с плавающей точкой и `numeric/decimal` с указанной точностью.

![[Pasted image 20240830204444.png]]

Выбор между целочисленными достаточно прост: если значения в пределах сотни, используется стандартный 4-байтовый `integer`, а если нужно больше то резервировать под них 8-байтовый `bigint`.
`numeric`  используется для различных "денежных" вещей, где нельзя допускать потери мелчайших округлении.
```
SELECT 3.1415926::real;
--     3.1415925 - чуток потеряли
SELECT 3.1415926::numeric;
--     3.1415926 - а тут все четко
```

Но вот что может вызывать недоумение:
* `serial` - псевдотипы (аналог `AUTO_INCREMENT / IDENTITY` из других СУБД), оно позволяет определять поля с автоматически возрастающим значением "по умолчанию": `1, 2, 3, ...`
* нет `unsigned` - все числовые типы знаковые, поэтому не получится положить 
  `[0x000000...0xFFFFFFF]` в `integer`.

##### Символьные типы
Символьные/строковые типы представлены парой описанных в стандарте `char/varchar` и парой PostgreSQL-спецефичных `bpchar/text`.

![[Pasted image 20240830212601.png]]

Если не предполагается перенос на другую СУБД, то можно использовать тип `text` везде, поскольку указание ограничение длины ни на что не влияет. Кроме моментов, где действительно требуется ограничить длину - например, для 2-буквенного кода страны.

##### Типы даты/времени
Дата и время хранятся как целочисленные, со значением от POSTGRES_EPOCH (01.01.2000) в соответствующих единицах (микросекундах или сутках).

![[Pasted image 20240830213335.png]]

В отличии от других СУБД, где `timestamp` может хранится как текстовая строка.

А раз это числа, то тут доступны арифметические операции, в том числе преобразование к Unix time.
```
SELECT '2024-01-01'::date - 1;
-- 2023-12-31 - за день до
SELECT '2024-01-01'::DATE - 8 * '1 hour'::interval;
-- 2023-12-31 16:00:00 - за 8 часов до
SELECT extract(epoch from '2024-01-01'::timestamp);
-- 1704067200 - превратили timestamp в double precision
SELECT '1970-01-01 00:00:00'::timestamp + 1704067200 * '1 second'::interval;
-- 2024-01-01 00:00:00 - ... и обратно
```

##### Логический тип
Логические значения представлены типом `boolean`.
![[Pasted image 20240830214147.png]]

Принимает значение `TRUE/FALSE`, с учетом специфики, значение `NULL`, равно как и любой другой тип.

#### Специальные типы данных
Помимо базовых типов, представляет массу других специализированных типов:
```
двоичные данные, перечисления, геометрические, сетевые адреса, битовые строки, вектора текстового поиска, UUID, XML, JSON, массивы, диапазоны.
```

Можно даже создать и свой и работать с ним как с любым другим полем. Главное, правильно его описать, задать соответствующие функции ввода-вывода, хранения и обработки.

